## 一，为什么要克隆

克隆的对象可能包含一些已经修改过的属性,保留着你想克隆对象的值，而new出来的对象的属性全是一个新的对象，对应的属性没有值，所以我们还要重新给这个对象赋值。即当需要一个新的对象来保存当前对象的“状态”就靠clone方法了。那么我把这个对象的临时属性一个一个的赋值给我新new的对象不也行嘛？可以是可以，但是一来麻烦不说，二来，大家通过上面的源码都发现了clone是一个native方法，就是快啊，在底层实现的。

## 二，如何实现克隆

分三步：
对象的类实现Cloneable接口；
覆盖Object类的clone()方法 （覆盖clone()方法，访问修饰符设为public，默认是protected）；
在clone()方法中调用super.clone()；

## 三，两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。

**浅克隆**：指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。
**深克隆**：不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。

## 四．Java的clone()方法

⑴clone方法将对象复制了一份并返回给调用者。一般而言，clone（）方法满足：
①对任何的对象x，都有x.clone() !=x//克隆对象与原对象不是同一个对象
②对任何的对象x，都有x.clone().getClass()= =x.getClass()//克隆对象与原对象的类型一样
③如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。
⑵Java中对象的克隆
①为了获取对象的一份拷贝，我们可以利用Object类的clone()方法。 
②在派生类中覆盖基类的clone()方法，并声明为public。 
③在派生类的clone()方法中，调用super.clone()。 
④在派生类中实现Cloneable接口。

## 五，深克隆的实现方式

1，类的引用类型属性（以及属性的引用类型属性）都进行浅克隆，直到没有引用类型属性或者引用类型属性为null时，整体上就形成了深克隆。既对象的引用类型属性和属性的应用类型属性都实现Coloneable，重写clone方法并在clone方法中进行调用。
2.使用对象流将对象写入流然后再读出是进行的深克隆。